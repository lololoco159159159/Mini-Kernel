Passo 1 – Estrutura de projeto e Makefile   ---feito
O que deve ser implementado:
    Criar a árvore de diretórios e arquivos-base do projeto (main.c, scheduler.c/h, queue.c/h, log.c/h, structures.h, Makefile).
    Makefile com targets para monoprocessador e multiprocessador, usando flags (-D MONO e -D MULTI).
    Target clean para apagar o executável.
    Testar a compilação básica.

Passo 2 – Definir estruturas PCB, TCB e enums 
O que deve ser implementado:
    Enum com estados do processo (READY, RUNNING, FINISHED).
    Estrutura do PCB (campos definidos na especificação, mutex e variável de condição).
    Estrutura do TCB (ponteiro para PCB + índice da thread no processo).
    Garantir que essas estruturas reflitam todos os campos exigidos pela spec, pois serão base de todo o código.

Passo 3 – Fila de prontos (ready queue) 
O que deve ser implementado:
    Estrutura de fila com mutex para proteger acesso concorrente.
    Funções para:
        Inserir no final.
        Remover no início.
        Remover elemento específico (para preempção por prioridade).
        Buscar processo de maior prioridade.
    Escolher implementação (lista encadeada simples ou fila circular).
    Garantir controle de concorrência no acesso.

Passo 4 – Funções de log 
O que deve ser implementado:
    Buffer global para armazenar mensagens de log durante toda a simulação.
    Função para adicionar mensagens formatadas ao buffer.
    Função para salvar o conteúdo em arquivo no final (log_execucao_minikernel.txt).
    Nenhum printf para o terminal — apenas log em arquivo.


Passo 5 – Leitura do arquivo de entrada e inicialização de PCBs 
O que deve ser implementado:
    Abrir e ler o arquivo especificado na linha de comando.
    Ler número de processos.
    Ler dados de cada processo (duração, prioridade, número de threads, tempo de chegada).
    Preencher a lista/array de PCBs:
        Inicializar remaining_time, estado inicial como READY, mutex, condicional, alocar vetor de threads.
    Ler política de escalonamento e armazenar numa variável global.

Passo 6 – Thread geradora de processos
O que deve ser implementado:
    Criar função de thread responsável por:
        Monitorar o tempo decorrido desde o início da simulação.
        Ao atingir o tempo de chegada de cada processo:
            Criar threads correspondentes ao processo (com função thread_func).
            Inserir processo na fila de prontos.
        Sinalizar quando todos os processos foram criados e enfileirados (generator_done = 1).

================== feito ate aqui ^ ==================

Passo 7 – Função da thread de execução de processo
O que deve ser implementado:
    Função que representa a execução de cada thread:
        Aguardar sinal do escalonador (condicional) enquanto estado != RUNNING e != FINISHED.
        Ao ser acordada, simular execução (usleep 500ms).
        Decrementar remaining_time de forma segura (mutex).
        Se remaining_time <= 0, mudar estado para FINISHED e sinalizar todas as threads do mesmo processo.
        Encerrar quando estado for FINISHED.

Passo 8 – Função do escalonador
O que deve ser implementado:
    Função para a thread escalonadora (1 para mono, 2 para multi):
        Enquanto houver processos prontos ou ainda não criados:
            Selecionar próximo processo com base na política:
                FCFS: pegar primeiro da fila.
                RR: pegar primeiro, executar quantum, re-enfileirar se ainda tiver tempo.
                Prioridade: pegar maior prioridade, preemptar se chegar processo mais prioritário.
            Mudar estado para RUNNING e acordar threads do processo.
            Esperar pelo término (FCFS) ou quantum (RR/Prioridade).
            Registrar eventos no log.
        No multiprocessador: cada escalonador atua sobre a mesma fila, respeitando a regra de só executar threads do mesmo processo simultaneamente quando não há outro processo disponível (obs.txt).

Passo 9 – Finalização
O que deve ser implementado:
    Garantir término de todas as threads dos processos (pthread_join).
    Salvar log no arquivo.
    Liberar memória alocada (vetores de threads, lista de PCBs, filas).
    Destruir mutexes e variáveis de condição.

